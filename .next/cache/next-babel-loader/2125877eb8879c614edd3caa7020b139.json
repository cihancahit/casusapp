{"ast":null,"code":"import _JSXStyle from \"styled-jsx/style\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { useEffect, useState, useContext } from \"react\";\nimport Router from \"next/router\";\nimport withDarkMode from \"next-dark-mode\";\nimport { NextDarkModeContext } from \"next-dark-mode\";\nimport Page from \"../components/Page\";\nimport { appWithTranslation } from \"../utils/i18n\";\nimport { initGA, logPageView } from \"../utils/analytics\";\n\nfunction MyApp({\n  Component,\n  pageProps\n}) {\n  const {\n    autoModeActive,\n    autoModeSupported,\n    darkModeActive,\n    switchToAutoMode,\n    switchToDarkMode,\n    switchToLightMode\n  } = useContext(NextDarkModeContext);\n  const {\n    0: loading,\n    1: setLoading\n  } = useState(false);\n  useEffect(() => {\n    initGA();\n    logPageView();\n\n    const loadingStart = () => setLoading(true);\n\n    const loadingStop = () => {\n      logPageView();\n      setLoading(false);\n    };\n\n    Router.events.on(\"routeChangeStart\", loadingStart);\n    Router.events.on(\"routeChangeComplete\", loadingStop);\n    return () => {\n      Router.events.off(\"routeChangeStart\", loadingStart);\n      Router.events.off(\"routeChangeComplete\", loadingStop);\n    };\n  }, []);\n\n  const onThemeToggle = () => darkModeActive ? switchToLightMode() : switchToDarkMode();\n\n  return __jsx(Page, {\n    onThemeToggle: onThemeToggle,\n    darkModeActive: darkModeActive\n  }, __jsx(Component, _extends({}, pageProps, {\n    loading: loading,\n    onThemeToggle: onThemeToggle\n  })), darkModeActive && __jsx(_JSXStyle, {\n    id: \"364031621\"\n  }, [\"body{background-color:#121212;color:white;-webkit-transition:background-color 0.2s linear;transition:background-color 0.2s linear;}\", \".footer,.language-list{color:#ddd;}\", \"button:hover,button:active,button:focus{color:white;}\", \"button:active{background-color:#555;}\", \"button{background-color:#222;color:white;border-color:#aaa;-webkit-transition:background-color 0.2s linear;transition:background-color 0.2s linear;}\", \"input[type=\\\"text\\\"],select,.box,.lobby-player-list>.player-box{border-color:#aaa !important;background-color:#333 !important;color:white !important;}\", \".game-countdown{color:#ddd;}\", \".spyfall-back{-webkit-filter:invert(1);filter:invert(1);}\", \".access-code,.access-code>span{color:#fff;}\", \".box-striked{background-color:#333 !important;color:grey !important;}\"]));\n} // Only uncomment this method if you have blocking data requirements for\n// every single page in your application. This disables the ability to\n// perform automatic static optimization, causing every page in your app to\n// be server-side rendered.\n//\n// MyApp.getInitialProps = async (appContext) => {\n//   // calls page's `getInitialProps` and fills `appProps.pageProps`\n//   const appProps = await App.getInitialProps(appContext);\n//\n//   return { ...appProps }\n// }\n\n\nexport default withDarkMode(appWithTranslation(MyApp));","map":null,"metadata":{},"sourceType":"module"}